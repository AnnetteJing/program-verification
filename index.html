<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<title>CS208E Final Project: Proofs of Program Correctness</title>

	<!-- bootstrap -->
	<link rel="stylesheet" href="style/bootstrap.min.css">
	<link rel="stylesheet" href="style/bootstrap-theme.min.css">

	<!-- Google fonts -->
	<link href="style/css.html" rel="stylesheet" type="text/css">

	<!-- Google Analytics -->
	<script async="" src="scripts/analytics.js"></script>
	<script>
		(function (i, s, o, g, r, a, m) {
			i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
				(i[r].q = i[r].q || []).push(arguments)
			}, i[r].l = 1 * new Date(); a = s.createElement(o),
				m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
		})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

		ga('create', 'UA-60458624-1', 'auto');
		ga('send', 'pageview');
	</script>

	<link rel="stylesheet" type="text/css" href="style/style.css">

</head>

<nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Home</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="1_background.html">Background</a></li>
        <li><a href="2_timeline.html">Timeline</a></li>
        <li><a href="3_related.html">Related Topics</a></li>
        <li><a href="4_thoughts.html">Our Thoughts</a></li>
        <li><a href="5_references.html">References</a></li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

<body>

	<div id="header">
		<a href="https://web.stanford.edu/class/cs208e/">
			<img src="images/Stanford.png" style="height:40px; float: left; 
			margin-left: 20px; margin-right: 10px">
		</a>
		<h1 class="increase" style="text-align:left">
			CS208E Final Project: Proofs of Program Correctness
		</h1>
		<div style="clear:both;"></div>
	</div>

	<div class="sechighlight">
		<div class="container sec">
			<h2>Project Prompt</h2>
			<div id="coursedesc">
				In many areas in computing, practice has been improved substantially by exploiting theoretical results. 
				One area in which the success of this marriage of theory and practice has been more mixed is in the field of program semantics, which seeks to capture the meaning of a program in mathematical terms and then to prove that the program implements its formal specification. 
				In a fascinating 1979 article entitled
				<a href="https://www.cs.umd.edu/~gasarch/BLOGPAPERS/social.pdf">
					<div class="inline">"Social Processes and Proofs of Theorems and Programs,"</div>
				</a>
				U.S. computer scientists Richard DeMillo, Richard Lipton, and Alan J. Perlis argued that the idea of proving programs correct is fundamentally misguided, generating a firestorm of controversy among computer scientists on both sides of the Atlantic. 
				That paper and its myriad responses in the letters pages of Communications of the ACM over the following year (all of which was reprised a decade later after a
				<a href="https://dl.acm.org/doi/10.1145/48529.48530">
					<div class="inline">follow-on article by James Fetzer</div>
				</a>
				appeared in the same journal) define what I think is one of the most interesting philosophical debates in the history of computing.
			</div>
		</div>

		<div class="container sec">
			<div class="row">
				<div class="col-md-8">
					<h2>Project Teammates</h2>
					<div class="instructor">
						<a href="https://www.linkedin.com/in/annette-jing-70235ab6/">
							<div class="instructorphoto"><img src="images/annette_jing.jpg"></div>
							<div>Annette Jing<br> &nbsp;</div>
						</a>
					</div>
					<div class="instructor">
						<a href="https://dlcl.stanford.edu/people/cristian-felipe-soler-reyes">
							<div class="instructorphoto"><img src="images/cristian_soler.jpg"></div>
							<div>Cristian Soler<br> &nbsp;</div>
						</a>
					</div>
				</div>
			</div>
		</div>

		<div class="container sec">
			<h2>Summaries of the Main References</h2>

			<br>

			<h4>“Social Processes and Proofs of Theorems and Programs,” De Millo, Lipton, and Perlis (1979)</h4>
			<div id="coursedesc">
				<p>
				Formal verification of programs could be considered as an important logical tool that grants validity to a program and increases the programmer's confidence in its correct functioning. This tool can give programming a more mathematical outlook. However, De Millo, Lipton, and Perlis argue in their article that formal verification cannot give the same amount of confidence to a program that it can give to a theorem. 
				Their proposal begins by stating that theorems are not simply believed because their proofs describe a fact correctly or because they are internally consistent. In the process of believing in a theorem there are several social processes that come into play: there has to be some enthusiasm by the mathematician working on the proof, this proof has to become a message that can be understood and transmitted by a community of mathematicians, and the applications of this theorem have to become useful and reliable (as it happens with bridges and classical stress equations). 
				</p>
				<p>
				Contrary to mathematical proofs, formal verification cannot become a message. While a proof of a theorem strives for simplicity, verifications are for the most part a long chain of deductive logic. But the authors go one step further in invalidating formal verification as a trustworthy tool, for them proofs in mathematics are not equivalent to formal verification in programming. The program in itself, the fact that it works, is its own proof; thus, formal verification does not add much information or confidence to it. In this article the authors see programs as tools that are in constant change, they answer to new social needs, they perform new tasks, they adapt to different environments. Formal verification is a long and tedious operation that can only slow down, according to the authors, these processes. If the idea is to create better and more reliable programs, one must come to terms with the fact that there are not perfect mechanisms. Instead, programmers can look at those structures that have worked in the past and try to make improvements on them, just like mathematicians also do.
				</p>
			</div>

			<hr>

			<h4>“Program Verification: The Very Idea,” James Fetzer (1989)</h4>
			<div id="coursedesc">
				<p>
				In an article published almost ten years after the one by De Millo, Lipton, and Perlis, James Fetzer tried to give an answer to several concerns raised by them. Although Fetzer will agree with these authors on the fact that program verification cannot be a totally reliable and applicable method for guaranteeing the reliability of a program, he will do so for different reasons. One first point of contention is the role played by social processes. For Fetzer, although social elements can play a role in the acceptance of a certain theorem as valid, they do not constitute a proof that these theorems are valid. In that sense, social processing is not necessary nor sufficient for a proof to become valid. Mathematical proofs, and Fetzer extends this to computer programs too, are deductive arguments, they do not expand our knowledge but they preserve a particular truth by showing that a certain group of axioms and rules are consistent with each other.
				</p>
				<p>
				Fetzer supports the analogy between mathematical proofs and computer programs by arguing that both are “syntactical entities consisting of sequences of lines (strings of signs and the like), they both appear to be completely formalized entities for which completely formal procedures appear to be appropriate.” However, what could distinguish these two is that programs are written to be read and executed by a machine, while proofs are not, and it is in this act of performing a program that mistakes can be made, unpredictable results can take place, and program verification could be considered as useless. Still, Fetzer argues that programs are a collection of algorithms, and these algorithms can be analogous to pure mathematics, the one that relies on proofs, while the programs are the application of these proofs. Thus, although Fetzer considers program verification as not reliable enough, he does not think that this is because programs are the product of social processes. Instead, he argues that this happens because programs develop as complex systems of which algorithms are its constituent simple elements. And while complex systems can become unpredictable, those simple elements are not and can be logically formalized. 
				</p>
			</div>

		</div>

		<div id="footer">
			<div id="classicons">
				Modified from webdesign by 
				<a href="https://karpathy.ai" target="_blank">Andrej Karpathy</a>
				<br>
			</div>
		</div>

	</div>

	<!-- jQuery and Boostrap -->
	<script src="scripts/jquery.min.js"></script>
	<script src="scripts/bootstrap.min.js"></script>

</body>

</html>

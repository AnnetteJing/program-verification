<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<title>CS208E Final Project: Proofs of Program Correctness</title>

	<!-- bootstrap -->
	<link rel="stylesheet" href="style/bootstrap.min.css">
	<link rel="stylesheet" href="style/bootstrap-theme.min.css">

	<!-- Google fonts -->
	<link href="style/css.html" rel="stylesheet" type="text/css">

	<!-- Google Analytics -->
	<script async="" src="scripts/analytics.js"></script>
	<script>
		(function (i, s, o, g, r, a, m) {
			i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
				(i[r].q = i[r].q || []).push(arguments)
			}, i[r].l = 1 * new Date(); a = s.createElement(o),
				m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
		})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

		ga('create', 'UA-60458624-1', 'auto');
		ga('send', 'pageview');
	</script>

	<link rel="stylesheet" type="text/css" href="style/style.css">

</head>

<nav class="navbar navbar-default navbar-fixed-top">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Home</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="1_background.html">Background</a></li>
        <li><a href="2_timeline.html">Timeline</a></li>
        <li><a href="3_related.html">Related Topics</a></li>
        <li><a href="4_thoughts.html">Our Thoughts</a></li>
        <li><a href="5_references.html">References</a></li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

<body>

	<div id="header">
		<h1 class="increase" style="text-align:center">
			Our Personal Views on the Subject
		</h1>
		<div style="clear:both;"></div>
	</div>

	<div class="sechighlight">
		<div class="container sec">
			<h4>Annette - Thoughts from an Objectivist</h4>
			<div id="coursedesc">
				<ul>
					<li>The truth of a theorem is separate from our beliefs about its truth.</li>
					<ul>
						<li>I largely agree with Fetzer's view on the validity of a theorem/algorithm's truth being innate and not dependent on a social process.</li>
						<li>Social processes affect our perception of the truth, but does not affect it.</li>
					</ul>
					<li>Probablistic proofs can be formal still.</li>
					<ul>
						<li>Probablity itself has a formal mathematical system.</li>
						<li>By rephrasing a statement in terms of appropriate premises from this system and a boundary probability, we can transform it into an argument that can be subjected to deductive reasoning.</li>
						<li>Given all the uncertainties in the "physical world" and our limited ability to perceive them, describing phenomena using the probability system might bring us more meaningful results.</li>
						<li>The informality then comes from the jump from <b>real-life uncertainty</b> to <b>probability axioms</b>, where inductive reasoning is still required. Like the jump from theoretical algorithms to executable programs, this is an approximation that may be worthwhile pursuing.</li>
					</ul>
					<li>The performance of programs is <b>subjective</b>, but can be transformed into a formal quantity.</li>
					<ul>
						<li>For example, suppose our program computes vectors of grocery prices for two stores and tells us which store is better.</li>
						<li>Further assume A wants to buy as many items as possible, regardless of what kind of item it is, while B wants to buy one of each item.</li>
						<li>For A, the program is correct only if it returns the store with the smaller minimal price; for B, however, the program should return the store with the smaller sum of prices.</li>
						<li>This demonstrates the need for two things: 1) good program specifications and/or theorem premises that <b>accurately approximate</b> a target subject's demands; 2) <b>enought variation</b> in program specifications and/or theorem premises that can cover most, if not all, of humanity's needs.</li>
					</ul>
					<li><b>Imperfection</b> does not invalidate the (potential) <b>usefulness</b> of verification.</li>
					<ul>
						<li>Based on the argument above, I believe the usefulness of verification depends on the program specifications' ability to approximate enough people's demands well. This is because both "correct" specifications and a valid algorithm are required for a "correct" output. Here, correctness need not be binary and can differ between people.</li>
						<li>Perfection requires the approximation to satisfy every single person to the maximal degree, if a maximum even exists. This appears to be impossible.</li>
						<li>"Approximate enough people's demands well" is again subjective, but I hold the optimistic viewpoint that the field will continue to thrive as long as it satisfies a sufficient amount of people.</li>
					</ul>
				</ul>
			</div>

			<hr>

			<h4>Cristian - Almost Random Thoughts on Verification</h4>
			<div id="coursedesc">
				<ul>
					<li>Programming is more a craft than a science.</li>
					<ul>
						<li>Like many crafts it can be standardized through and supported by mathematics.</li>
					</ul>
					<li>Programs are tools.</li>
					<ul>
						<li>They are complex tools that can connect with other tools and create a network of tools.</li>
						<li>Designing tools is designing ways of being.</li>
					</ul>
					<li>Program verification is also a tool.</li>
					<ul>
						<li>This tool can test specific functions of a program and its reliability in a specific context.</li>
						<li>Program verifications must be designed with the specific functions and contexts they are testing in mind.</li>
						<li>There cannot be a program verification that can verify all programs in all their possible applications.</li>
						<li>The best way to verify a program is to test it in a real case scenario.</li>
					</ul>
					<li>Tools are designed and used by humans.</li>
					<ul>
						<li>Their utility and correctness depend on how well they perform the tasks for which they were designed or how well they fulfill some of our personal and social needs.</li>
					</ul>
				</ul>
			</div>


		<div id="footer">
			<div id="classicons">
				Modified from webdesign by 
				<a href="https://karpathy.ai" target="_blank">Andrej Karpathy</a>
				<br>
			</div>
		</div>
			
	</div>

	<!-- jQuery and Boostrap -->
	<script src="scripts/jquery.min.js"></script>
	<script src="scripts/bootstrap.min.js"></script>

</body>

</html>